<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Improved Space Invaders</title>
    <style>
        /* 全体のリセットと基本設定 */
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden; /* スクロール禁止 */
            background-color: #000; /* デフォルトの背景色を黒に設定（ゲーム画面外） */
            font-family: 'Arial', sans-serif;
            color: #fff;
            -webkit-user-select: none; /* テキスト選択無効化 (iOS) */
            -moz-user-select: none; /* テキスト選択無効化 (Firefox) */
            -ms-user-select: none; /* テキスト選択無効化 (IE/Edge) */
            user-select: none; /* テキスト選択無効化 (標準) */
            -webkit-tap-highlight-color: rgba(0,0,0,0); /* タップ時のハイライトを無効化 (iOS) */
        }

        /* 画面中央にゲームコンテンツを配置するためのFlexbox */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* 画面全体の高さ */
            width: 100vw; /* 画面全体の幅 */
            position: relative; /* 子要素の絶対配置の基準 */
        }

        /* ゲームコンテナ - キャンバスと動画、UI要素を内包 */
        #gameContainer {
            position: relative; /* 子要素（canvas, video）の基準 */
            width: 420px; /* GAME_WIDTHと同期 */
            height: calc(420px * (19.5 / 9)); /* GAME_HEIGHTと同期 */
            overflow: hidden; /* はみ出たコンテンツを隠す */
            border: 2px solid #0f0; /* ゲーム画面の枠線 */
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.8);
            z-index: 1; /* 他のUIより手前 */
            margin: auto; /* 画面中央に配置 */
            box-sizing: border-box; /* パディングとボーダーを幅と高さに含める */
        }

        /* スマートフォンなど、画面幅が768px以下のデバイスにのみ適用するスタイル */
        @media (max-width: 768px) {
            #gameContainer {
                width: min(100vw, calc(100vh * (9 / 19.5)));
                height: min(calc(100vw * (19.5 / 9)), 100vh);
                /* safe-area-inset は必要に応じて追加してください。
                   現状のコードにはないので今回は含めません。
                padding-top: env(safe-area-inset-top);
                padding-bottom: env(safe-area-inset-bottom);
                padding-left: env(safe-area-inset-left);
                padding-right: env(safe-area-inset-right);
                */
            }
        }

        /* ゲームキャンバス */
        #gameCanvas {
            position: absolute; /* gameContainerを基準に配置 */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block; /* 初期状態はJSで制御 */
            z-index: 0; /* 動画より手前 */
            background-color: lightgray; /* ゲームプレイ中の背景色をライトグレーに設定 */
        }

        /* 背景動画 - gameContainerのサイズに合わせる */
        #background-video {
            position: absolute; /* gameContainerを基準に配置 */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover; /* 縦横比を維持しつつ要素を覆う */
            filter: brightness(0.5); /* 少し暗くして見やすくする */
            z-index: -1; /* キャンバスより奥に配置 */
            display: block; /* 初期状態はJSで制御 */
        }

        /* スコア、ライフ、レベル表示 */
        #score, #lives, #level {
            position: absolute;
            font-size: 1.2em;
            font-weight: bold;
            color: #0f0;
            text-shadow: 0 0 5px #0f0;
            z-index: 2; /* ゲーム要素より手前 */
            padding: 5px 10px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
        }
        #score { top: 10px; left: 10px; }
        #lives { top: 10px; right: 10px; }
        #level { bottom: 10px; left: 10px; }

        /* メッセージボックス (ゲームオーバー/クリア時) */
        #messageBox {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            border: 2px solid #0f0;
            padding: 20px;
            text-align: center;
            z-index: 3;
            display: none;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.8);
            max-width: 80%;
            box-sizing: border-box; /* パディングを含めて幅を計算 */
        }
        #messageBox p {
            margin: 0 0 20px 0;
            font-size: 1.5em;
            font-weight: bold;
            color: #0f0;
            text-shadow: 0 0 5px #0f0;
        }
        #messageBox button {
            background-color: #0f0;
            color: #000;
            border: none;
            padding: 10px 20px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.3s, color 0.3s;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        #messageBox button:hover {
            background-color: #0a0;
            color: #fff;
        }

        /* スタートボタンコンテナ */
        #startButtonContainer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #0f0;
            padding: 30px 40px;
            border-radius: 15px;
            box-shadow: 0 0 25px rgba(0, 255, 0, 0.8);
            z-index: 2; /* ゲーム画面より手前 */
            width: 80%; /* 適度な幅に */
            max-width: 400px; /* 最大幅 */
            box-sizing: border-box; /* パディングを含めて幅を計算 */
        }
        #startButtonContainer h1 {
            font-size: 2.5em;
            color: #0f0;
            text-shadow: 0 0 10px #0f0;
            margin-bottom: 10px;
            text-align: center;
        }
        #startButtonContainer p {
            font-size: 1.2em;
            color: #fff;
            margin-bottom: 30px;
            text-align: center;
        }
        #startButton {
            background-color: #0f0;
            color: #000;
            border: none;
            padding: 15px 30px;
            font-size: 1.5em;
            font-weight: bold;
            cursor: pointer;
            border-radius: 8px;
            transition: background-color 0.3s, color 0.3s, transform 0.1s;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
            white-space: nowrap; /* ボタン内のテキストが改行されないように */
        }
        #startButton:hover {
            background-color: #0a0;
            color: #fff;
        }
        #startButton:active {
            transform: scale(0.98);
        }

        /* ローディングメッセージ */
        #loadingMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.8em;
            font-weight: bold;
            color: #0f0;
            text-shadow: 0 0 8px #0f0;
            z-index: 4;
            display: none;
        }

        /* 音量スライダー */
        .volume-control {
            margin-top: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1em;
            color: #fff;
        }
        #volumeSlider {
            width: 150px;
            -webkit-appearance: none; /* デフォルトスタイルを無効化 */
            appearance: none;
            height: 8px;
            background: #333;
            outline: none;
            border-radius: 4px;
            cursor: pointer;
            box-shadow: inset 0 0 5px rgba(0, 255, 0, 0.3);
        }
        #volumeSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #0f0;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.7);
        }
        #volumeSlider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #0f0;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.7);
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
</head>
<body>
    <div id="loadingMessage">Loading Game Assets...</div>

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <video autoplay loop muted playsinline id="background-video">
            <source src="video/background_loop.mp4" type="video/mp4">
            Your browser does not support the video tag.
        </video>
        <div id="score">Score: 0</div>
        <div id="lives">Lives: 3</div>
        <div id="level">Level: 1</div>
    </div>

    <div id="messageBox">
        <p id="message"></p>
        <button>Play Again</button>
    </div>

    <div id="startButtonContainer">
        <h1>SPACE INVADERS</h1>
        <p>Improved</p>
        <button id="startButton">TAP TO START</button>
        <div class="volume-control">
            <span>Volume</span>
            <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="0.5">
        </div>
    </div>

    <script>
        // --- Global Constants ---
        const GAME_WIDTH = 420;
        const GAME_HEIGHT = GAME_WIDTH * (19.5 / 9); // Aspect ratio for mobile portrait
        const PLAYER_SPEED = 7;
        const PLAYER_PROJECTILE_SPEED = 10;
        const INVADER_BASE_SPEED = 15; // 修正: 20から15に減少（インベーダーの初期移動速度）
        const INVADER_MOVE_DOWN_AMOUNT = 20; // インベーダーが下に移動する量

        // ★難易度調整: 敵の弾速を少し上げる
        const ENEMY_PROJECTILE_SPEED = 5; // 変更: 4 -> 5

        const INVADER_ROWS = 5; // ★修正: 6から5に戻す（敵の行数）
        const INVADER_COLS = 5; // （敵の列数）
        const INVADER_WIDTH = 75; // （敵の表示サイズ）
        const INVADER_HEIGHT = 75; // （敵の表示サイズ）

        // インベーダー間の横方向の間隔と縦方向の間隔を調整
        const INVADER_SPACING_X = 10; // インベーダー間の横方向の間隔を詰める
        const INVADER_SPACING_Y = 15; // インベーダー間の縦方向の間隔を調整

        const BOSS_WIDTH = 150; // ★変更: ボスの幅を大きく
        const BOSS_HEIGHT = 120; // ★変更: ボスの高さを大きく
        const BOSS_HP_PER_LEVEL = 10; // （ボスのHP）
        const MAX_LEVELS = 30; // ★難易度調整: 最大レベル数を30に設定

        const PLAYER_WIDTH = 40; // 修正: 30から40に増加（自機の表示サイズ）
        const PLAYER_HEIGHT = 40; // 修正: 30から40に増加（自機の表示サイズ）
        const PLAYER_SHOOT_COOLDOWN_MAX = 15; // 修正: 20から15に減少（自機の発射間隔）

        // ボスの放射状ミサイル関連の定数
        const BOSS_RADIAL_PROJECTILE_COUNT_BASE = 3; // ボスの初期放射状ミサイル数
        const BOSS_RADIAL_SPREAD_ANGLE = Math.PI * 0.75; // 放射状に広がる角度（ラジアン、例: 135度）
        
        // ★追加★ 最終ボス関連の定数
        const FINAL_BOSS_WIDTH = 200; // 最終ボスの幅（例として通常のボスの約1.3倍）
        const FINAL_BOSS_HEIGHT = 150; // 最終ボスの高さ
        const FINAL_BOSS_HP = 30; // 最終ボスのHP（30発）
        const FINAL_BOSS_SHOOT_INTERVAL = 90; // 最終ボスの発射間隔（フレーム数、例: 1.5秒に1回）
        const HOMING_MISSILE_SPEED = 4; // ホーミングミサイルの速度（例として敵弾より少し速め）
        const HOMING_MISSILE_TURN_SPEED = 0.05; // ホーミングミサイルの旋回速度（ラジアン/フレーム、値が大きいほど急旋回）
        const HOMING_MISSILE_SIZE = 8; // ホーミングミサイルの表示サイズ（半径）
        const HOMING_MISSILE_COLOR = '#ff0000'; // ホーミングミサイルの色（例: 赤）
        const FINAL_BOSS_RADIAL_PROJECTILE_COUNT = 5; // 最終ボスが一度に発射するホーミング弾の数（例: 5発）


        const GAME_STATE = {
            LOADING: 'LOADING',
            START_SCREEN: 'START_SCREEN', // 最初の「TAP TO START」で動画再生
            PLAYING: 'PLAYING', // 実際のゲームプレイ中
            GAME_OVER: 'GAME_OVER', // ゲームオーバー/クリア画面
            FINAL_BOSS: 'FINAL_BOSS' // ★最終ボス状態を追加★
        };

        // --- Global Variables ---
        let canvas, ctx;
        let player;
        let invaders = [];
        let projectiles = [];
        let invaderProjectiles = []; // invaderProjectilesはボスや通常の敵の弾を扱う
        let score = 0;
        let lives = 3;
        let currentLevel = 1;
        let lastTimestamp = 0;
        let animationFrameId;
        let currentGameState = GAME_STATE.LOADING;
        let loadedImages = {};
        let loadedAudio = {};
        let boss = null;
        let bossCreatedForThisLevel = false; // ★追加: ボスがこのレベルで生成されたかどうかのフラグ
        let finalBoss = null; // ★最終ボスオブジェクトを追加★

        // Player shooting cooldown
        let playerShootCooldown = 0;

        // Player movement target for touch/mouse
        let playerTargetX = null;
        let isPointerDown = false; // Tracks if mouse/touch is currently pressed

        // UI elements
        let scoreDisplay;
        let livesDisplay;
        let levelDisplay;
        let messageBox;
        let messageText;
        let startButtonContainer;
        let startButton;
        let loadingMessage;
        let volumeSlider; // 音量スライダー
        let backgroundMusic; // Howler.js BGM
        let backgroundVideo; // 背景動画要素

        // Invader movement flags
        let lastInvaderMoveDownTime = 0;
        const INVADER_MOVE_DOWN_INTERVAL = 1500; // ★修正: 500から1500に増加（インベーダーが下に移動する間隔（ミリ秒））

        let isInitialStartTapDone = false; // 最初のタップ（動画再生）が完了したかどうかのフラグ

        // --- Initialization ---

        function init() {
            console.log("init function started"); // ★この行を追加★
        initGameEssentials();
            initGameEssentials();
            showLoadingMessage(); // ロード開始時にローディングメッセージを表示
            loadAssets().then(() => {
                hideLoadingMessage();
                currentGameState = GAME_STATE.START_SCREEN;
                showStartButton(); // これで「TAP TO START」が表示される

                // 音量スライダーの初期値を設定し、イベントリスナーを追加
                const savedVolume = parseFloat(localStorage.getItem('gameVolume')) || 0.5;
                Howler.volume(savedVolume);
                volumeSlider.value = savedVolume;

                volumeSlider.addEventListener('input', (e) => {
                    const newVolume = parseFloat(e.target.value);
                    Howler.volume(newVolume); // Howler.jsのグローバル音量を更新
                    localStorage.setItem('gameVolume', newVolume); // 音量設定をローカルストレージに保存

                    if (backgroundVideo) {
                        backgroundVideo.volume = newVolume;
                        if (newVolume > 0 && backgroundVideo.muted) {
                            backgroundVideo.muted = false;
                        } else if (newVolume === 0 && !backgroundVideo.muted) {
                            backgroundVideo.muted = true;
                        }
                    }
                });

                // スタートボタンのクリックイベントリスナー
                startButton.addEventListener('click', () => {
                    if (currentGameState === GAME_STATE.START_SCREEN) {
                        if (!isInitialStartTapDone) {
                            // 1回目のタップ：動画再生とボタンテキスト変更
                            if (backgroundVideo) {
                                backgroundVideo.muted = false; // ミュート解除
                                backgroundVideo.volume = Howler.volume(); // スライダーの音量に合わせる
                                backgroundVideo.play().catch(e => console.error("Video playback error on first tap:", e));
                                backgroundVideo.style.display = 'block'; // 動画を表示
                                backgroundVideo.style.zIndex = -1; // キャンバスより奥に配置
                            }
                            startButton.innerText = "START GAME"; // ボタンのテキストを変更
                            isInitialStartTapDone = true; // フラグを立てる
                             // BGMを再生（Howler.jsで管理）
                            if (loadedAudio.backgroundMusic) {
                                if (!loadedAudio.backgroundMusic.playing()) {
                                    loadedAudio.backgroundMusic.play();
                                    loadedAudio.backgroundMusic.loop(true);
                                     // 音量スライダーの値が反映されるようにここでvolumeを設定
                                    loadedAudio.backgroundMusic.volume(Howler.volume());
                                }
                            }
                        } else {
                            // 2回目のタップ：ゲーム開始
                            startGame(true); // 新しいゲームを開始
                        }
                    }
                });
            }).catch(error => {
                console.error("Error loading assets:", error);
                loadingMessage.innerText = `Error loading assets: ${error.message || error}. Please check console for details.`;
            });
        }

        // Sets up canvas, player object, and event listeners once
        function initGameEssentials() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;
            canvas.style.display = 'none'; // ゲーム開始前はキャンバスを非表示にする

            // UI elements
            scoreDisplay = document.getElementById('score');
            livesDisplay = document.getElementById('lives');
            levelDisplay = document.getElementById('level');
            messageBox = document.getElementById('messageBox');
            messageText = messageBox.querySelector('p');
            startButtonContainer = document.getElementById('startButtonContainer');
            startButton = document.getElementById('startButton');
            loadingMessage = document.getElementById('loadingMessage');
            volumeSlider = document.getElementById('volumeSlider'); // スライダー要素を取得

            // 背景動画要素を取得
            backgroundVideo = document.getElementById('background-video');
            if (backgroundVideo) {
                backgroundVideo.style.display = 'none'; // 最初は隠す
                backgroundVideo.muted = true; // 最初はミュートにする
                 backgroundVideo.volume = 0; //念のため音量も0に
            }

            player = {
                x: GAME_WIDTH / 2 - PLAYER_WIDTH / 2,
                y: GAME_HEIGHT - PLAYER_HEIGHT - 120,
                width: PLAYER_WIDTH,
                height: PLAYER_HEIGHT,
                movingLeft: false,
                movingRight: false,
                invincible: false, // Is player invincible?
                invincibleTimer: 0, // How long player has been invincible
                blinkTimer: 0 // For blinking effect
            };

            // Input Event Listeners
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);

            // Touch event listeners for mobile
            document.body.addEventListener('touchstart', handleTouchStart, { passive: false });
            document.body.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.body.addEventListener('touchend', handleTouchEnd);

            // Mouse event listeners for desktop
            document.body.addEventListener('mousedown', handleMouseDown);
            document.body.addEventListener('mousemove', handleMouseMove);
            document.body.addEventListener('mouseup', handleMouseUp);

            // Screen orientation lock (非対応デバイスでは警告が出るが、処理は続行)
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('portrait')
                    .then(() => console.log("画面の向きを縦向きにロックしました。"))
                    .catch(error => console.warn("画面の向きをロックできませんでした。:", error.name, error.message));
            }
        }

        function loadAssets() {
            const imagePromises = [
                // プレイヤーの画像
                loadImage('player', 'image/invader3.png'),

                // インベーダーの画像
                loadImage('invader', 'image/invader1.png'),

                // ボスの画像
                loadImage('boss', 'image/invader2.png'), // 通常ボス画像

                // ★追加: ボス爆発の画像 (通常ボスと最終ボス共通で使用)
                loadImage('boss_explosion', 'image/explosion.png'),

                // ★最終ボス画像を追加（ここでは通常ボスと同じ画像を再利用）★
                loadImage('finalBoss', 'image/final_boss.png'),
            ];
            const audioPromises = [
                loadAudio('backgroundMusic', 'audio/bgm_amelo1.mp3'),
                // 他のサウンドをここに追加ロードすることもできます (例: invaderHit, bossHit, bossExplosion, bossSpawn, playerHit)
                loadAudio('shoot', 'audio/shoot.mp3'), // ★ミサイル音を有効化
                 loadAudio('finalBossMusic', 'audio/boss_bgm.mp3') // ★最終ボス用BGMを追加★ (必要に応じてパスを変更)
                // loadAudio('invaderHit', 'audio/invader_hit.mp3'),
                // loadAudio('bossHit', 'audio/boss_hit.mp3'),
                // loadAudio('bossExplosion', 'audio/boss_explosion.mp3'),
                // loadAudio('bossSpawn', 'audio/boss_spawn.mp3'), // ボス出現音 (必要であれば)
                // loadAudio('playerHit', 'audio/player_hit.mp3'), // 自機被弾音 (必要であれば)
            ];
            return Promise.all([...imagePromises, ...audioPromises]);
        }

        function loadImage(name, src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.src = src;
                img.onload = () => {
                    loadedImages[name] = img;
                    resolve();
                };
                img.onerror = (e) => reject(new Error(`Failed to load image: ${src} (${e.message || e})`));
            });
        }

        function loadAudio(name, src) {
            return new Promise((resolve, reject) => {
                const sound = new Howl({
                    src: [src],
                    volume: Howler.volume(),
                    onload: () => {
                        loadedAudio[name] = sound;
                        if (name === 'shoot') { // もし読み込んだ音がミサイル音(shoot)なら
                             sound.volume(0.05); // その音の個別音量を0.5に設定する (ここを調整！)
                           }
                         if (name === 'finalBossMusic') { // 最終ボスBGMの音量調整
                             sound.volume(Howler.volume()); // グローバル音量に合わせる
                         }
                        resolve(); // 音声がロードされたらPromiseを解決
                    },
                    onloaderror: (id, error) => reject(new Error(`Failed to load audio: ${src} (ID: ${id}, Error: ${error})`))
                });
            });
        }

        // --- UI Visibility Functions ---
        function showLoadingMessage() {
            loadingMessage.style.display = 'block';
            startButtonContainer.style.display = 'none';
            messageBox.style.display = 'none';
            canvas.style.display = 'none';
             if (backgroundVideo) {
                 backgroundVideo.style.display = 'none';
                 backgroundVideo.pause();
                 backgroundVideo.currentTime = 0;
                 backgroundVideo.muted = true;
             }
        }

        function hideLoadingMessage() {
            loadingMessage.style.display = 'none';
        }

        function showStartButton() {
            startButtonContainer.style.display = 'flex';
            messageBox.style.display = 'none';
            canvas.style.display = 'none';

            if (backgroundVideo) {
                // スタート画面では動画を表示
                backgroundVideo.style.display = 'block';
                backgroundVideo.currentTime = 0; // 動画を最初から再生
                backgroundVideo.muted = false; // 再生時のみミュートを解除
                backgroundVideo.volume = Howler.volume(); // スライダーの音量に合わせる
                backgroundVideo.play().catch(e => console.error("Video playback error on start screen:", e));
                backgroundVideo.style.zIndex = -1; // キャンバスより奥に
            }

            currentGameState = GAME_STATE.START_SCREEN;
            startButton.innerText = "TAP TO START";
            isInitialStartTapDone = false;
        }

        function hideStartButton() {
            startButtonContainer.style.display = 'none';

            // ゲーム開始時に背景動画を非表示にする
            if (backgroundVideo) {
                backgroundVideo.style.display = 'none'; // 動画を非表示にする
                backgroundVideo.pause(); // 動画を一時停止する
                backgroundVideo.currentTime = 0; // 動画の再生位置をリセット
            }
            canvas.style.display = 'block'; // キャンバスを表示
        }

        function showMessage(msg) {
            messageText.innerText = msg;
            messageBox.style.display = 'block';
        }

        function hideMessageBox() {
            messageBox.style.display = 'none';
        }

        function updateScoreDisplay() {
            scoreDisplay.innerText = `Score: ${score}`;
        }

        function updateLivesDisplay() {
            livesDisplay.innerText = `Lives: ${lives}`;
        }

        function updateLevelDisplay() {
            levelDisplay.innerText = `Level: ${currentLevel}`;
        }

        // --- Game State Management ---

        function createInvaders() {
            invaders = [];
            // インベーダー全体の幅を計算
            const totalInvaderBlockWidth = (INVADER_COLS * INVADER_WIDTH) + ((INVADER_COLS - 1) * INVADER_SPACING_X);
            // 開始X座標を計算（中央揃え）
            const startX = (GAME_WIDTH - totalInvaderBlockWidth) / 2;
            const startY = 80; // インベーダーの初期Y座標は高く保つ

            for (let row = 0; row < INVADER_ROWS; row++) {
                for (let col = 0; col < INVADER_COLS; col++) {
                    invaders.push({
                        x: startX + col * (INVADER_WIDTH + INVADER_SPACING_X),
                        y: startY + row * (INVADER_HEIGHT + INVADER_SPACING_Y),
                        width: INVADER_WIDTH,
                        height: INVADER_HEIGHT,
                        dx: (INVADER_BASE_SPEED + (currentLevel - 1) * 7),
                        hp: 1
                    });
                }
            }
        }

        function createBoss() {
            boss = {
                x: GAME_WIDTH / 2 - BOSS_WIDTH / 2,
                y: 30,
                width: BOSS_WIDTH,
                height: BOSS_HEIGHT,
                dx: (INVADER_BASE_SPEED + (currentLevel - 1) * 13) * 1.5,
                hp: BOSS_HP_PER_LEVEL,
                shootTimer: 0,
                shootInterval: Math.max(60, 120 - (currentLevel - 1) * 18),
                isExploding: false,
                explosionTimer: 0,
                explosionDuration: 50,
                originalImage: 'boss',
                explosionImage: 'boss_explosion'
            };
        }

        // ★追加★ 最終ボスオブジェクトを生成する関数
        function createFinalBoss() {
            finalBoss = {
                x: GAME_WIDTH / 2 - FINAL_BOSS_WIDTH / 2, // 画面中央上部に配置
                y: 50, // Y座標は画面上部
                width: FINAL_BOSS_WIDTH,
                height: FINAL_BOSS_HEIGHT,
                hp: FINAL_BOSS_HP, // 最終ボスのHP
                shootTimer: 0, // 発射間隔を管理するタイマー
                shootInterval: FINAL_BOSS_SHOOT_INTERVAL, // 最終ボスの発射間隔
                isExploding: false, // 爆発アニメーション用
                explosionTimer: 0,
                explosionDuration: 50, // 爆発アニメーションの長さ（任意）
                originalImage: 'finalBoss', // 最終ボス画像
                explosionImage: 'boss_explosion' // 爆発画像
            };
        }

        // ★追加★ 最終ボス戦を開始する関数
        function startFinalBossBattle() {
            currentGameState = GAME_STATE.FINAL_BOSS; // 状態を最終ボス戦に変更

            // 残っているオブジェクトを全てクリア
            invaders = [];
            boss = null;
            projectiles = []; // プレイヤーの弾も消す
            invaderProjectiles = []; // 敵の弾も消す

            createFinalBoss(); // 最終ボスを生成

            // 最終ボス戦用の音楽があればここで再生
             if (loadedAudio.finalBossMusic) {
                 if (loadedAudio.backgroundMusic && loadedAudio.backgroundMusic.playing()) {
                     loadedAudio.backgroundMusic.stop(); // 元のBGMを停止
                 }
                 if (!loadedAudio.finalBossMusic.playing()) {
                    loadedAudio.finalBossMusic.play();
                    loadedAudio.finalBossMusic.loop(true);
                    loadedAudio.finalBossMusic.volume(Howler.volume());
                 }
             } else if (loadedAudio.backgroundMusic && loadedAudio.backgroundMusic.playing()) {
                 // 最終ボス用BGMがない場合、元のBGMを継続
                 loadedAudio.backgroundMusic.volume(Howler.volume()); // 音量を戻すなど
             }

        
        function startGame(isNewGame) {
           console.log("startGame function started with isNewGame:", isNewGame); // ★この行を追加★
        if (animationFrameId) {
          
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            if (isNewGame) {
                score = 0;
                lives = 3;
                currentLevel = 1;
            } else {
                // 既存のゲームからの継続の場合、プレイヤーの状態のみリセット
                player.x = GAME_WIDTH / 2 - PLAYER_WIDTH / 2;
                player.movingLeft = false;
                player.movingRight = false;
                player.invincible = false;
                player.invincibleTimer = 0;
                player.blinkTimer = 0;
            }

            boss = null; // ボスは最初に生成しない（インベーダー全滅後に生成）
            bossCreatedForThisLevel = false; // 新しいゲームまたはレベル開始時にリセット
            finalBoss = null; // ゲーム開始時に最終ボスもリセット
            projectiles = [];
            invaderProjectiles = [];

            // 最終レベル以外はインベーダーを生成
            if (currentLevel < MAX_LEVELS) {
                createInvaders(); // まずインベーダーのみを生成
            } else {
                 // レベルMAXの場合はインベーダーは生成せず、直接通常ボスを生成（レベル30のボス戦）
                 createBoss();
            }

            updateScoreDisplay();
            updateLivesDisplay();
            updateLevelDisplay();
            hideMessageBox();
            hideStartButton(); // ゲーム開始時に動画を非表示にしキャンバスを表示

            currentGameState = GAME_STATE.PLAYING;
            lastTimestamp = performance.now();

            // ★修正：音楽が既に再生中でなければ再生開始、ループを設定
             if (loadedAudio.backgroundMusic && !loadedAudio.backgroundMusic.playing()) {
                 loadedAudio.backgroundMusic.play();
                 loadedAudio.backgroundMusic.loop(true); // ループを有効にする
                 loadedAudio.backgroundMusic.volume(Howler.volume());
             } else if (loadedAudio.finalBossMusic && loadedAudio.finalBossMusic.playing()) {
                  // 最終ボス戦から戻った場合など、最終ボスBGMが再生中の場合は停止
                  loadedAudio.finalBossMusic.stop();
                  if (loadedAudio.backgroundMusic) {
                      loadedAudio.backgroundMusic.play();
                      loadedAudio.backgroundMusic.loop(true);
                      loadedAudio.backgroundMusic.volume(Howler.volume());
                  }
             }


        // ★修正★ endGame 関数全体を置き換え (レベルMAXクリアで最終ボスへ遷移)
        function endGame(win) {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            // BGMを停止するタイミングをここで一元管理
             if (loadedAudio.backgroundMusic && loadedAudio.backgroundMusic.playing()) {
                 loadedAudio.backgroundMusic.stop();
             }
             if (loadedAudio.finalBossMusic && loadedAudio.finalBossMusic.playing()) {
                 loadedAudio.finalBossMusic.stop();
             }

            // 共通の後処理：背景動画はゲームオーバー/クリア時も基本非表示に保つ（スタート画面に戻る時のみ表示）
            if (backgroundVideo) {
                backgroundVideo.style.display = 'none';
                backgroundVideo.pause();
                backgroundVideo.currentTime = 0;
                backgroundVideo.muted = true;
            }
            canvas.style.display = 'block'; // ゲームオーバー/クリア画面でもキャンバスは表示しておく

            let message = '';
            const playAgainButton = messageBox.querySelector('button');

            if (win) {
                // レベルクリア時または最終ボス撃破時
                // currentLevel >= MAX_LEVELS かつボス/最終ボスがいない状態で win=true は最終クリアを意味する
                if (currentLevel >= MAX_LEVELS && boss === null && finalBoss === null) {
                     // ★最終クリア！
                     message = `CONGRATULATIONS! YOU SAVED OUR SPACE! Final Score: ${score}`;
                     playAgainButton.innerText = "Play Again";
                     playAgainButton.onclick = () => {
                         hideMessageBox();
                         showStartButton(); // 全てリセットしてスタート画面へ
                     };
                     // ゲームクリア時はスタート画面用の動画を表示
                     if (backgroundVideo) {
                         backgroundVideo.style.display = 'block';
                         backgroundVideo.currentTime = 0;
                         backgroundVideo.muted = false;
                         backgroundVideo.volume = Howler.volume();
                         backgroundVideo.play().catch(e => console.error("Video playback error on game over/win:", e));
                         backgroundVideo.style.zIndex = -1;
                     }
                     canvas.style.display = 'none'; // 動画表示のためキャンバスを非表示


                } else if (currentLevel < MAX_LEVELS || (currentLevel >= MAX_LEVELS && boss && boss.hp <= 0)) { // 通常レベルクリア または レベルMAXの通常ボス撃破
                     // ★通常レベルクリア または レベルMAXの通常ボス撃破 -> 最終ボス戦へ移行または次のレベルへ
                     if (currentLevel < MAX_LEVELS) {
                          // 通常レベルクリア
                         message = `Level ${currentLevel} Clear! Score: ${score}`;
                         currentLevel++; // 次のレベルへ進む
                         playAgainButton.innerText = `Next Level (${currentLevel})`;
                         playAgainButton.onclick = () => {
                             hideMessageBox();
                             // 次のレベルへ直接移行し、最初のスタート画面に戻らない
                             startGame(false); // isNewGame=false で現在のスコア・ライフ・レベルを継続
                         };
                     } else { // レベルMAXの通常ボス撃破
                         // レベルMAXクリア！最終ボス戦へ移行するためのメッセージ
                        message = `Level ${currentLevel} Clear! Prepare for the Final Battle! Score: ${score}`;
                        playAgainButton.innerText = `Face the Final Boss`;
                        playAgainButton.onclick = () => {
                            hideMessageBox();
                            // 最終ボス戦の準備と開始
                            startFinalBossBattle(); // 新しい関数を呼び出す
                        };
                     }
                     // 中間レベルクリアや最終ボス戦移行画面では動画を非表示に保ち、キャンバスを表示
                     canvas.style.display = 'block';

                } else {
                     // 想定外のクリア状態の場合（デバッグ用）
                     console.warn("Unknown win condition met.", { currentGameState, currentLevel, boss, finalBoss });
                     message = `Level Clear? Score: ${score}`;
                     playAgainButton.innerText = "Continue?";
                      playAgainButton.onclick = () => {
                         hideMessageBox();
                         showStartButton(); // 安全のためスタート画面へ
                     };
                     canvas.style.display = 'block'; // 安全のためキャンバスを表示
                }
            } else {
                // ゲームオーバー（敗北）の場合
                message = `Game Over! Score: ${score}`;
                playAgainButton.innerText = "Play Again";
                playAgainButton.onclick = () => {
                    hideMessageBox();
                    showStartButton(); // 全てのゲーム状態をリセットし、最初の「TAP TO START」画面に戻る
                };
                // 最終クリアまたはゲームオーバー時はスタート画面用の動画を再表示
                if (backgroundVideo) {
                    backgroundVideo.style.display = 'block';
                    backgroundVideo.currentTime = 0;
                    backgroundVideo.muted = false;
                    backgroundVideo.volume = Howler.volume();
                    backgroundVideo.play().catch(e => console.error("Video playback error on game over/win:", e));
                    backgroundVideo.style.zIndex = -1;
                }
                canvas.style.display = 'none'; // 動画表示中はキャンバスを非表示
            }

            // GAME_OVER 状態に遷移
            currentGameState = GAME_STATE.GAME_OVER; // メッセージ表示中は GAME_OVER 状態とする
            showMessage(message); // メッセージボックスを表示
        }


        // ★修正★ update 関数全体を置き換え (最終ボス戦の更新処理を追加)
        function update(timestamp) {
            // ゲームオーバー状態の場合は更新処理を行わない
            if (currentGameState === GAME_STATE.GAME_OVER) {
                 return;
            }

            const deltaTime = (timestamp - lastTimestamp) / 1000; // 経過時間（秒）
            lastTimestamp = timestamp;

            // --- プレイヤーの移動 ---
            // PLAYING または FINAL_BOSS 状態でのみプレイヤーは移動
            if (currentGameState === GAME_STATE.PLAYING || currentGameState === GAME_STATE.FINAL_BOSS) {
                if (isPointerDown && playerTargetX !== null) {
                    // ポインター/タッチ操作: ターゲット位置へ移動
                    const playerCenter = player.x + player.width / 2;
                    const distanceToTarget = playerTargetX - playerCenter;
                    const moveAmount = PLAYER_SPEED;

                    if (distanceToTarget > 0 && Math.abs(distanceToTarget) > moveAmount / 2) {
                        player.x += moveAmount;
                    } else if (distanceToTarget < 0 && Math.abs(distanceToTarget) > moveAmount / 2) {
                        player.x -= moveAmount;
                    }
                    // 画面端でのクランプ処理
                    player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));

                    // 移動中に発射（タップ/クリック押しっぱなしで連射）
                    if (playerShootCooldown <= 0) {
                        createPlayerProjectile();
                        if (loadedAudio.shoot) {
                            loadedAudio.shoot.play();
                        }
                        playerShootCooldown = PLAYER_SHOOT_COOLDOWN_MAX;
                    }

                } else {
                    // キーボード操作
                    if (player.movingLeft) {
                        player.x -= PLAYER_SPEED;
                    }
                    if (player.movingRight) {
                        player.x += PLAYER_SPEED;
                    }
                    // 画面端でのクランプ処理
                    player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
                }

                // プレイヤーの発射クールダウン
                if (playerShootCooldown > 0) {
                    playerShootCooldown--;
                }

                 // プレイヤーの無敵時間の更新
                if (player && player.invincible) { // player オブジェクトが存在するか確認
                    player.invincibleTimer--;
                    player.blinkTimer++; // 点滅タイマーを進行
                    if (player.invincibleTimer <= 0) {
                        player.invincible = false;
                        player.blinkTimer = 0; // 無敵終了時に点滅タイマーもリセット
                    }
                }
            }


            // --- インベーダーの更新 ---
            // PLAYING 状態でのみインベーダーを更新
            if (currentGameState === GAME_STATE.PLAYING) {
                let hitSide = false;
                for (let i = 0; i < invaders.length; i++) {
                    const invader = invaders[i];
                    invader.x += invader.dx * deltaTime;

                    // 端に到達したらフラグを立てる
                    if (invader.x + invader.width > canvas.width || invader.x < 0) {
                        hitSide = true;
                    }

                    // ランダムなタイミングで弾を発射
                    if (Math.random() < 0.002 + (currentLevel - 1) * 0.00015) {
                        createInvaderProjectile(invader.x + invader.width / 2, invader.y + invader.height);
                    }

                    // インベーダーがプレイヤーの高さに到達したらゲームオーバー
                    if (invader.y + invader.height > player.y - 20) {
                        endGame(false); // Game Over
                        return; // Stop updating
                    }
                }

                // 端に到達したインベーダーがいたら全体を一段階下に移動し、方向を反転
                const currentTime = performance.now();
                if (hitSide) {
                     invaders.forEach(invader => { invader.dx *= -1; });
                     invaders.forEach(invader => { invader.y += INVADER_MOVE_DOWN_AMOUNT; });
                     lastInvaderMoveDownTime = currentTime;
                } else if (currentTime - lastInvaderMoveDownTime > INVADER_MOVE_DOWN_INTERVAL) {
                    invaders.forEach(invader => { invader.y += INVADER_MOVE_DOWN_AMOUNT; });
                    lastInvaderMoveDownTime = currentTime;
                }
            }


            // --- 通常ボスの更新 (PLAYING 状態かつボスがいるときのみ) ---
            if (currentGameState === GAME_STATE.PLAYING && boss && !boss.isExploding) {
                boss.x += boss.dx * deltaTime;

                // 端に到達したら方向反転
                if (boss.x + boss.width > canvas.width || boss.x < 0) {
                    boss.dx *= -1;
                }

                // ボスの発射タイマー
                boss.shootTimer++;
                if (boss.shootTimer >= boss.shootInterval) {
                     createBossRadialProjectiles(boss.x + boss.width / 2, boss.y + boss.height);
                     boss.shootTimer = 0;
                }
            } else if (currentGameState === GAME_STATE.PLAYING && boss && boss.isExploding) {
                // ボス爆発アニメーションの更新
                boss.explosionTimer--;
                if (boss.explosionTimer <= 0) {
                    boss = null; // 爆発アニメーション終了後にボスオブジェクトを削除
                }
            }


            // ★追加★ 最終ボスの更新 (FINAL_BOSS 状態かつ最終ボスがいるときのみ) ---
             if (currentGameState === GAME_STATE.FINAL_BOSS && finalBoss && !finalBoss.isExploding) {
                 // 最終ボスは動かないので位置更新は不要

                 // 最終ボスの発射タイマー
                 finalBoss.shootTimer++;
                 if (finalBoss.shootTimer >= finalBoss.shootInterval) {
                     createHomingMissiles(finalBoss.x + finalBoss.width / 2, finalBoss.y + finalBoss.height);
                     finalBoss.shootTimer = 0;
                 }
             } else if (currentGameState === GAME_STATE.FINAL_BOSS && finalBoss && finalBoss.isExploding) {
                 // 最終ボス爆発アニメーションの更新
                 finalBoss.explosionTimer--;
                 if (finalBoss.explosionTimer <= 0) {
                     // 最終ボス撃破！ゲームクリア！
                     finalBoss = null;
                     endGame(true); // ゲームクリア処理を呼び出す
                     return; // Stop updating
                 }
             }


            // --- ゲームクリア判定 (PLAYING 状態でのみ) ---
            // インベーダーが全滅し、かつ通常ボスがいない場合、レベルクリア（または最終ボス戦へ）
            // PLAYING状態でのみ判定し、ボスがいないことを確認してから判定
            if (currentGameState === GAME_STATE.PLAYING && invaders.length === 0 && boss === null) {
                 // レベルMAXの場合は最終ボス戦へ移行、それ以外は次のレベルへ
                 if (currentLevel >= MAX_LEVELS) {
                      // レベルMAXクリア。endGame(true)で最終ボス戦移行画面へ
                      // endGame(true) の中で状態が GAME_OVER (メッセージ表示) に遷移する（ボタンタップで FINAL_BOSS へ）
                      endGame(true);
                      return; // update ループを抜ける
                 } else {
                      // 通常レベルクリア。endGame(true)で次のレベル開始画面へ
                      // endGame(true) の中で状態が GAME_OVER (メッセージ表示) になり、ボタンタップで次のレベルが始まる
                      endGame(true);
                      return; // update ループを抜ける
                 }
            }


            // --- プレイヤーの弾の更新 ---
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const projectile = projectiles[i];
                projectile.y -= projectile.speed;

                // 画面外に出たプレイヤーの弾を削除
                if (projectile.y + projectile.height < 0) {
                    projectiles.splice(i, 1);
                }
            }


            // --- 敵の弾 (インベーダー・ボス・最終ボス) の更新 ---
            for (let i = invaderProjectiles.length - 1; i >= 0; i--) {
                const projectile = invaderProjectiles[i];

                // ★追加★ ホーミングミサイルの追尾処理 (FINAL_BOSS 状態かつホーミング弾の場合のみ)
                if (projectile.isHoming && player && currentGameState === GAME_STATE.FINAL_BOSS) {
                    const targetX = player.x + player.width / 2;
                    const targetY = player.y + player.height / 2;
                    const projectileCenterX = projectile.x + projectile.radius;
                    const projectileCenterY = projectile.y + projectile.radius;

                    const deltaX = targetX - projectileCenterX;
                    const deltaY = targetY - projectileCenterY;

                    const currentAngle = Math.atan2(projectile.dy, projectile.dx);
                    const targetAngle = Math.atan2(deltaY, deltaX);

                    let angleDiff = targetAngle - currentAngle;
                    if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

                    const turn = Math.max(-HOMING_MISSILE_TURN_SPEED, Math.min(HOMING_MISSILE_TURN_SPEED, angleDiff));
                    const newAngle = currentAngle + turn;

                    projectile.dx = Math.cos(newAngle) * HOMING_MISSILE_SPEED;
                    projectile.dy = Math.sin(newAngle) * HOMING_MISSILE_SPEED;

                    projectile.x += projectile.dx;
                    projectile.y += projectile.dy;

                } else { // 通常の敵弾の場合
                     if (projectile.hasOwnProperty('dx') && projectile.hasOwnProperty('dy')) {
                          // dx, dy を持つ弾（通常ボスの放射状弾など）
                         projectile.x += projectile.dx;
                         projectile.y += projectile.dy;
                     } else if (projectile.hasOwnProperty('speed')) {
                         // speed を持つ弾（通常のインベーダーの弾など）
                         projectile.y += projectile.speed; // 下方向にのみ移動
                     }
                }

                // 画面外に出た敵の弾を削除
                // ホーミングミサイルも含むので横方向の判定も必要
                if (projectile.y > canvas.height + 20 || projectile.x < -20 || projectile.x > canvas.width + 20) {
                    invaderProjectiles.splice(i, 1);
                }
            }


            // --- 衝突判定 ---
            // プレイヤーの弾と敵（インベーダー、通常ボス、最終ボス）の衝突
            // 敵の弾とプレイヤーの衝突
            // 判定処理は PLAYING または FINAL_BOSS 状態でのみ実行

            // プレイヤーの弾 vs インベーダー (PLAYING 状態のときのみ)
            if (currentGameState === GAME_STATE.PLAYING) {
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const projectile = projectiles[i];
                    for (let j = invaders.length - 1; j >= 0; j--) {
                        const invader = invaders[j];

                        if (projectile.x < invader.x + invader.width &&
                            projectile.x + projectile.width > invader.x &&
                            projectile.y < invader.y + invader.height &&
                            projectile.y + projectile.height > invader.y) {

                            projectiles.splice(i, 1);
                            invaders.splice(j, 1);
                            score += 10;
                            updateScoreDisplay();
                            // if (loadedAudio.invaderHit) loadedAudio.invaderHit.play();

                            break;
                        }
                    }
                }
            }

            // プレイヤーの弾 vs 通常ボス (PLAYING 状態かつボスがいるときのみ)
            if (currentGameState === GAME_STATE.PLAYING && boss && !boss.isExploding) {
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const projectile = projectiles[i];

                    if (projectile.x < boss.x + boss.width &&
                        projectile.x + projectile.width > boss.x &&
                        projectile.y < boss.y + boss.height &&
                        projectile.y + projectile.height > boss.y) {

                        projectiles.splice(i, 1);
                        boss.hp--;
                        score += 50;
                        updateScoreDisplay();
                        // if (loadedAudio.bossHit) loadedAudio.bossHit.play();

                        if (boss.hp <= 0) {
                            boss.isExploding = true;
                            boss.explosionTimer = boss.explosionDuration;
                            score += 500;
                            updateScoreDisplay();
                            // if (loadedAudio.bossExplosion) loadedAudio.bossExplosion.play();
                        }
                        break;
                    }
                }
            }

            // ★追加★ プレイヤーの弾 vs 最終ボス (FINAL_BOSS 状態かつ最終ボスがいるときのみ)
            if (currentGameState === GAME_STATE.FINAL_BOSS && finalBoss && !finalBoss.isExploding) {
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const projectile = projectiles[i];

                    if (projectile.x < finalBoss.x + finalBoss.width &&
                        projectile.x + finalBoss.width > finalBoss.x &&
                        projectile.y < finalBoss.y + finalBoss.height &&
                        projectile.y + finalBoss.height > finalBoss.y) {

                        projectiles.splice(i, 1);
                        finalBoss.hp--;
                        score += 100;
                        updateScoreDisplay();
                        // if (loadedAudio.bossHit) loadedAudio.bossHit.play();

                        if (finalBoss.hp <= 0) {
                            finalBoss.isExploding = true;
                            finalBoss.explosionTimer = finalBoss.explosionDuration * 2;
                            score += 5000;
                            updateScoreDisplay();
                            // if (loadedAudio.bossExplosion) loadedAudio.bossExplosion.play();
                        }
                        break;
                    }
                }
            }


            // 敵の弾 (インベーダー・ボス・最終ボス) vs プレイヤー
            // PLAYING または FINAL_BOSS 状態でのみ、かつプレイヤーが無敵でない場合、かつライフが0より大きい場合のみ判定
            if ((currentGameState === GAME_STATE.PLAYING || currentGameState === GAME_STATE.FINAL_BOSS) && player && !player.invincible && lives > 0) {
                for (let i = invaderProjectiles.length - 1; i >= 0; i--) {
                    const projectile = invaderProjectiles[i];

                    // 衝突判定: ホーミングミサイルは円だが bounding box で判定
                    const projLeft = projectile.x;
                    const projRight = projectile.x + (projectile.isHoming ? projectile.radius * 2 : projectile.width);
                    const projTop = projectile.y;
                    const projBottom = projectile.y + (projectile.isHoming ? projectile.radius * 2 : projectile.height);

                    const playerLeft = player.x;
                    const playerRight = player.x + player.width;
                    const playerTop = player.y;
                    const playerBottom = player.y + player.height;


                    if (projRight > playerLeft &&
                        projLeft < playerRight &&
                        projBottom > playerTop &&
                        projTop < playerBottom) {

                        invaderProjectiles.splice(i, 1);
                        lives--;
                        updateLivesDisplay();
                        // if (loadedAudio.playerHit) loadedAudio.playerHit.play();

                        player.invincible = true;
                        player.invincibleTimer = 120;
                        player.blinkTimer = 0;

                        if (lives <= 0) {
                            endGame(false); // Game Over
                            return; // Stop updating
                        }
                        break;
                    }
                }
            }

            // プレイヤーの無敵時間の更新 (endGame で return しなかった場合のみ)
             if (player && player.invincibleTimer > 0) {
                 player.invincibleTimer--;
                 player.blinkTimer++;
                 if (player.invincibleTimer <= 0) {
                     player.invincible = false;
                     player.blinkTimer = 0;
                 }
             }


            animationFrameId = requestAnimationFrame(update);
        }

        // ★追加★ ボスが放射状の弾を発射する関数
        function createBossRadialProjectiles(startX, startY) {
            const count = BOSS_RADIAL_PROJECTILE_COUNT_BASE + Math.floor((currentLevel - 1) / 5);
            const angleStep = BOSS_RADIAL_SPREAD_ANGLE / Math.max(1, count - 1);
            const startAngle = Math.PI / 2 - BOSS_RADIAL_SPREAD_ANGLE / 2;

            for (let i = 0; i < count; i++) {
                const angle = startAngle + angleStep * i;
                 const bulletSpeed = ENEMY_PROJECTILE_SPEED * 1.2;
                const dx = Math.cos(angle) * bulletSpeed;
                const dy = Math.sin(angle) * bulletSpeed;
                createInvaderProjectile(startX, startY, bulletSpeed, false, dx, dy);
            }
        }

        // ★追加★ ホーミングミサイルを生成する関数
        function createHomingMissiles(startX, startY) {
            const count = FINAL_BOSS_RADIAL_PROJECTILE_COUNT;
            const initialAngle = Math.PI / 2;

            for (let i = 0; i < count; i++) {
                const dx = Math.cos(initialAngle) * HOMING_MISSILE_SPEED;
                const dy = Math.sin(initialAngle) * HOMING_MISSILE_SPEED;
                createInvaderProjectile(startX + (i - (count - 1) / 2) * (HOMING_MISSILE_SIZE * 2), startY, HOMING_MISSILE_SPEED, true, dx, dy);
            }
        }

        // 通常の敵弾を生成する関数（ホーミング弾と区別するために修正）
        // dx, dy を持つ放射状の弾にも対応できるよう汎用的に修正
        function createInvaderProjectile(x, y, speed = ENEMY_PROJECTILE_SPEED, isHoming = false, dx = 0, dy = speed) {
             // ホーミング弾の場合は radius を設定
             const radius = isHoming ? HOMING_MISSILE_SIZE : 0;
             const width = isHoming ? radius * 2 : 5; // 通常弾の幅
             const height = isHoming ? radius * 2 : 10; // 通常弾の高さ

            invaderProjectiles.push({
                x: x - width / 2, // 弾の中心を発射位置に合わせる
                y: y - height / 2, // 弾の中心を発射位置に合わせる
                width: width,
                height: height,
                radius: radius, // ホーミング弾用
                speed: speed, // 通常弾の速度として保持
                dx: dx, // 速度ベクトルX
                dy: dy, // 速度ベクトルY
                isHoming: isHoming // ホーミング弾であるかどうかのフラグ
            });
        }

        // プレイヤーの弾を生成する関数
        function createPlayerProjectile() {
            projectiles.push({
                x: player.x + player.width / 2 - 2.5, // 弾の幅の半分を考慮して中央に
                y: player.y,
                width: 5,
                height: 10,
                speed: PLAYER_PROJECTILE_SPEED
            });
        }

        // --- Drawing Functions ---
        function draw() {
             console.log("--- draw() call ---");
            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            // Draw player
            // 点滅効果のロジックを追加
            if (player.invincible && player.blinkTimer % 10 < 5) {
                // 非表示期間なので描画しない
            } else {
                if (loadedImages.player) {
                    ctx.drawImage(loadedImages.player, player.x, player.y, player.width, player.height);
                } else {
                    ctx.fillStyle = 'blue';
                    ctx.fillRect(player.x, player.y, player.width, player.height);
                }
            }

            // Draw invaders (PLAYING状態のみ)
            if (currentGameState === GAME_STATE.PLAYING) {
                invaders.forEach(invader => {
                    if (loadedImages.invader) {
                        ctx.drawImage(loadedImages.invader, invader.x, invader.y, invader.width, invader.height);
                    } else {
                        ctx.fillStyle = 'green';
                        ctx.fillRect(invader.x, invader.y, invader.width, invader.height);
                    }
                });
            }

            // Draw boss or boss explosion (PLAYING状態での通常ボスのみ)
            if (currentGameState === GAME_STATE.PLAYING && boss) {
                if (boss.isExploding && loadedImages[boss.explosionImage]) {
                    const frame = Math.floor(boss.explosionTimer / (boss.explosionDuration / 8));
                    const spriteWidth = 256;
                    const spriteHeight = 256;
                    const drawX = boss.x + boss.width / 2 - spriteWidth / 2;
                    const drawY = boss.y + boss.height / 2 - spriteHeight / 2;
                    const drawWidth = spriteWidth;
                    const drawHeight = spriteHeight;
                    ctx.drawImage(
                        loadedImages[boss.explosionImage],
                        frame * spriteWidth, 0, spriteWidth, spriteHeight,
                        drawX, drawY, drawWidth, drawHeight
                    );
                } else if (loadedImages[boss.originalImage]) {
                    ctx.drawImage(loadedImages[boss.originalImage], boss.x, boss.y, boss.width, boss.height);
                    // ボスのHPバーを描画
                    const hpBarWidth = boss.width * 0.8;
                    const hpBarHeight = 5;
                    const hpBarX = boss.x + (boss.width - hpBarWidth) / 2;
                    const hpBarY = boss.y + boss.height + 5;
                    ctx.fillStyle = 'red'; ctx.fillRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);
                    ctx.fillStyle = 'lime'; ctx.fillRect(hpBarX, hpBarY, hpBarWidth * (boss.hp / BOSS_HP_PER_LEVEL), hpBarHeight);
                    ctx.strokeStyle = '#0f0'; ctx.strokeRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);
                } else {
                    ctx.fillStyle = 'purple';
                    ctx.fillRect(boss.x, boss.y, boss.width, boss.height);
                }
            }

            // ★追加★ 最終ボスの描画 (FINAL_BOSS 状態かつ最終ボスがいるときのみ)
             if (currentGameState === GAME_STATE.FINAL_BOSS && finalBoss) {
                 if (finalBoss.isExploding && loadedImages[finalBoss.explosionImage]) {
                     // 最終ボス爆発のアニメーションを描画 (通常ボスと同じロジックを流用)
                     const frame = Math.floor(finalBoss.explosionTimer / (finalBoss.explosionDuration / 8));
                     const spriteWidth = 256;
                     const spriteHeight = 256;
                     const drawX = finalBoss.x + finalBoss.width / 2 - spriteWidth / 2;
                     const drawY = finalBoss.y + finalBoss.height / 2 - spriteHeight / 2;
                     const drawWidth = spriteWidth;
                     const drawHeight = spriteHeight;
                     ctx.drawImage(
                         loadedImages[finalBoss.explosionImage],
                         frame * spriteWidth, 0, spriteWidth, spriteHeight,
                         drawX, drawY, drawWidth, drawHeight
                     );

                 } else if (loadedImages[finalBoss.originalImage]) {
                     // 最終ボスの画像を描画
                     ctx.drawImage(loadedImages[finalBoss.originalImage], finalBoss.x, finalBoss.y, finalBoss.width, finalBoss.height);

                     // 最終ボスのHPバーを描画
                     const hpBarWidth = finalBoss.width * 0.9; // HPバーを少し大きく
                     const hpBarHeight = 7; // HPバーを少し太く
                     const hpBarX = finalBoss.x + (finalBoss.width - hpBarWidth) / 2;
                     const hpBarY = finalBoss.y + finalBoss.height + 10; // 少し下に表示

                     ctx.fillStyle = 'red'; ctx.fillRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);
                     // 最終ボスの最大HPは固定値 FINAL_BOSS_HP を使用
                     ctx.fillStyle = 'lime'; ctx.fillRect(hpBarX, hpBarY, hpBarWidth * (finalBoss.hp / FINAL_BOSS_HP), hpBarHeight);
                     ctx.strokeStyle = '#0f0'; ctx.strokeRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);

                 } else {
                     // 画像がない場合の代替描画
                     ctx.fillStyle = 'purple';
                     ctx.fillRect(finalBoss.x, finalBoss.y, finalBoss.width, finalBoss.height);
                 }
             }


            // Draw projectiles (自機の弾)
            projectiles.forEach(p => {
                ctx.fillStyle = 'yellow';
                ctx.fillRect(p.x, p.y, p.width, p.height);
            });

            // Draw invader projectiles (敵弾 - 通常敵とボス、最終ボス含む)
            invaderProjectiles.forEach(p => {
                 // ホーミングミサイルの場合は円を描画
                 if (p.isHoming) {
                     ctx.fillStyle = HOMING_MISSILE_COLOR;
                     ctx.beginPath();
                     ctx.arc(p.x + p.radius, p.y + p.radius, p.radius, 0, Math.PI * 2);
                     ctx.fill();
                 } else {
                    ctx.fillStyle = 'red'; // 通常の敵弾の色
                    ctx.fillRect(p.x, p.y, p.width, p.height);
                 }
            });
        }

        // --- Collision Detection ---

        function checkCollisions() {
            // Player projectiles hitting invaders (PLAYING状態のみ)
            if (currentGameState === GAME_STATE.PLAYING) {
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const projectile = projectiles[i];
                    for (let j = invaders.length - 1; j >= 0; j--) {
                        const invader = invaders[j];

                        if (isColliding(projectile, invader)) {
                            projectiles.splice(i, 1); // Remove projectile
                            invaders.splice(j, 1); // Remove invader
                            score += 10;
                            updateScoreDisplay();
                            // if (loadedAudio.invaderHit) loadedAudio.invaderHit.play();

                            break; // 1つの弾丸は1体のインベーダーにしか当たらない
                        }
                    }
                }
            }

            // Player projectiles hitting boss (PLAYING状態での通常ボスのみ)
            if (currentGameState === GAME_STATE.PLAYING && boss && !boss.isExploding) { // ボスが爆発中でなければ判定
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const projectile = projectiles[i];
                    if (isColliding(projectile, boss)) {
                        projectiles.splice(i, 1); // Remove projectile
                        boss.hp--;
                        score += 50; // ボス被弾でスコア加算
                        updateScoreDisplay();
                        // if (loadedAudio.bossHit) { loadedAudio.bossHit.play(); }
                        if (boss.hp <= 0) {
                            boss.isExploding = true; // ボスを爆発状態にする
                            boss.explosionTimer = 0; // 爆発タイマーをリセット
                             score += 500; // ボス撃破ボーナス (HP0になった時点で加算)
                             updateScoreDisplay();
                            // if (loadedAudio.bossExplosion) { loadedAudio.bossExplosion.play(); }
                        }
                        break; // ボスに当たったらその弾丸のチェックは終了
                    }
                }
            }

             // ★追加★ プレイヤーの弾丸が最終ボスに当たる衝突判定 (FINAL_BOSS 状態かつ最終ボスがいるときのみ)
             if (currentGameState === GAME_STATE.FINAL_BOSS && finalBoss && !finalBoss.isExploding) {
                 for (let i = projectiles.length - 1; i >= 0; i--) {
                     const projectile = projectiles[i];
                     if (isColliding(projectile, finalBoss)) {
                         projectiles.splice(i, 1); // プレイヤーの弾丸を削除
                         finalBoss.hp--; // 最終ボスのHPを減らす
                         score += 100; // 最終ボス被弾でスコア加算
                         updateScoreDisplay();
                            // 最終ボス被弾音があれば再生 (loadedAudio.finalBossHitなど)
                             if (finalBoss.hp <= 0) {
                                finalBoss.isExploding = true; // 最終ボスを爆発状態にする
                                finalBoss.explosionTimer = 0; // 爆発タイマーをリセット
                                 score += 5000; // 最終ボス撃破ボーナス (HP0になった時点で加算)
                                 updateScoreDisplay();
                                // 最終ボス爆発音があれば再生 (loadedAudio.finalBossExplosionなど)
                             }
                          break; // プレイヤーの弾丸のチェックを終了
                      }
                  }
              }


            // Invader projectiles hitting player (PLAYING状態とFINAL_BOSS状態の両方でチェック)
            // プレイヤーが無敵でない場合、かつライフが0より大きい場合のみ判定
            if ((currentGameState === GAME_STATE.PLAYING || currentGameState === GAME_STATE.FINAL_BOSS) && player && !player.invincible && lives > 0) {
                for (let i = invaderProjectiles.length - 1; i >= 0; i--) {
                    const projectile = invaderProjectiles[i];

                    // 衝突判定: オブジェクトに radius プロパティがあれば円として、なければ矩形として判定
                    const isProjCircle = projectile.hasOwnProperty('radius') && projectile.radius > 0;

                    if (isProjCircle) {
                         // 円と矩形の衝突判定 (ホーミングミサイルなど)
                         const circleX = projectile.x + projectile.radius;
                         const circleY = projectile.y + projectile.radius;
                         const circleRadius = projectile.radius;
                         const rectX = player.x;
                         const rectY = player.y;
                         const rectWidth = player.width;
                         const rectHeight = player.height;

                         // 矩形に最も近い円上の点を clampedX, clampedY とする
                         const clampedX = Math.max(rectX, Math.min(circleX, rectX + rectWidth));
                         const clampedY = Math.max(rectY, Math.min(circleY, rectY + rectHeight));

                         // 円の中心と最も近い点との距離を計算
                         const distanceX = circleX - clampedX;
                         const distanceY = circleY - clampedY;
                         const distanceSquared = (distanceX * distanceX) + (distanceY * distanceY);

                         // 距離の2乗が半径の2乗以下であれば衝突
                         if (distanceSquared <= (circleRadius * circleRadius)) {
                             // 衝突した弾丸を削除
                            invaderProjectiles.splice(i, 1); // Remove projectile (safe due to single target)
                             lives--;
                             updateLivesDisplay();
                             player.invincible = true;
                             player.invincibleTimer = 120; // 2秒無敵
                             player.blinkTimer = 0;

                             // if (loadedAudio.playerHit) { loadedAudio.playerHit.play(); }

                             // ゲームオーバー判定
                             if (lives <= 0 && currentGameState !== GAME_STATE.GAME_OVER) { // すでにゲームオーバー状態で重複して呼ばれないようにチェックを追加
                                 endGame(false); // ゲームオーバー
                                 return; // ゲームオーバー処理へ移行するため、update ループを抜ける
                             }
                             // プレイヤーに当たったらその弾丸のチェックは終了
                             break;
                         }
                    } else {
                         // 矩形と矩形の衝突判定 (通常の敵弾など)
                        if (isColliding(projectile, player)) {
                             // 衝突した弾丸を削除
                            invaderProjectiles.splice(i, 1); // Remove projectile (safe due to single target)
                             lives--;
                             updateLivesDisplay();
                             player.invincible = true;
                             player.invincibleTimer = 120; // 2秒無敵
                             player.blinkTimer = 0;

                             // if (loadedAudio.playerHit) { loadedAudio.playerHit.play(); }

                             // ゲームオーバー判定
                             if (lives <= 0 && currentGameState !== GAME_STATE.GAME_OVER) { // すでにゲームオーバー状態で重複して呼ばれないようにチェックを追加
                                 endGame(false); // ゲームオーバー
                                 return; // ゲームオーバー処理へ移行するため、update ループを抜ける
                             }
                             // プレイヤーに当たったらその弾丸のチェックは終了
                             break;
                         }
                    }
                }
            }
             // プレイヤーの無敵時間の更新 (衝突が発生し、endGame で return しなかった場合のみ)
             if (player && player.invincibleTimer > 0) {
                 player.invincibleTimer--;
                 player.blinkTimer++; // 点滅タイマーを進める
                 if (player.invincibleTimer <= 0) {
                     player.invincible = false;
                     player.blinkTimer = 0; // 点滅タイマーもリセット
                 }
             }
        }


        // Helper function for rectangle collision
        function isColliding(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }


        // --- Input Handling ---

        // handleKeyDown 関数
        function handleKeyDown(event) {
            // ゲームプレイ中 (PLAYING) または最終ボス戦中 (FINAL_BOSS) のみキー操作を有効にする
            // メッセージ表示中やスタート画面ではキー入力を無視
            if (currentGameState !== GAME_STATE.PLAYING && currentGameState !== GAME_STATE.FINAL_BOSS) {
                 // スタート画面でスペースキーを押した場合の特別な処理（START GAMEボタンの代わり）
                 if (currentGameState === GAME_STATE.START_SCREEN && event.key === ' ') {
                     // 最初のタップがまだで、ボタンが有効な場合のみ
                     if (!isInitialStartTapDone && startButton && !startButton.disabled) {
                         startButton.click(); // START GAME ボタンをクリックしたことにする (1回目のタップ)
                     } else if (isInitialStartTapDone && startButton && !startButton.disabled) {
                          startButton.click(); // START GAME ボタンをクリックしたことにする (2回目のタップ)
                     }
                 }
                 return;
            }

            switch (event.key) {
                case 'ArrowLeft':
                case 'a':
                    player.movingLeft = true;
                    break;
                case 'ArrowRight':
                case 'd':
                    player.movingRight = true;
                    break;
                case ' ': // Spacebar
                    // スペースキーによる発射はキーが押された瞬間のみ
                    // タップ/マウス操作での連射とは分けて処理
                    if (playerShootCooldown <= 0) {
                        createPlayerProjectile();
                        if (loadedAudio.shoot) {
                            loadedAudio.shoot.play();
                        }
                        playerShootCooldown = PLAYER_SHOOT_COOLDOWN_MAX;
                    }
                    break;
                 // ★追加★ デバッグ用キー (Lキーで最終ボス戦へスキップ)
                 case 'L':
                 case 'l': // 小文字も対応
                     if (currentGameState !== GAME_STATE.GAME_OVER && finalBoss === null) { // ゲームオーバー中でなく、かつ最終ボスがいない場合のみ有効
                         console.log("Debug: Skipping to Final Boss Level");
                         currentLevel = MAX_LEVELS; // レベルを最大に設定
                         // 残っているゲームオブジェクトをクリア
                         invaders = [];
                         boss = null;
                         projectiles = [];
                         invaderProjectiles = [];
                         finalBoss = null; // 念のためリセット
                         // 最終ボス戦開始
                         startFinalBossBattle();
                     }
                     break;
                 // ★追加★ デバッグ用キー (Kキーでゲームオーバー)
                 case 'K':
                 case 'k': // 小文字も対応
                      if (currentGameState !== GAME_STATE.GAME_OVER && currentGameState !== GAME_STATE.START_SCREEN && currentGameState !== GAME_STATE.LOADING) { // ゲームオーバーや開始画面以外で有効
                         console.log("Debug: Triggering Game Over");
                         lives = 0; // ライフを0に
                         endGame(false); // ゲームオーバー処理を呼び出す
                      }
                      break;
                 // ★追加★ デバッグ用キー (Wキーで通常レベルクリア/次のレベルへ)
                 case 'W':
                 case 'w': // 小文字も対応
                     // PLAYING状態かつゲームオーバー中でない、かつ最終ボス戦中でない場合のみ有効
                     if (currentGameState === GAME_STATE.PLAYING && currentGameState !== GAME_STATE.GAME_OVER && currentGameState !== GAME_STATE.FINAL_BOSS) {
                         console.log(`Debug: Skipping to Level ${currentLevel + 1}`);
                         // 残っている敵を全て削除
                         invaders = [];
                         boss = null;
                         projectiles = [];
                         invaderProjectiles = [];
                         // レベルクリア処理へ移行
                         endGame(true);
                     }
                     break;
            }
             // イベントのデフォルト動作を抑制 (スクロールなど防止)
             // デバッグキーも含む
             if (['ArrowLeft', 'ArrowRight', ' ', 'a', 'd', 'L', 'l', 'K', 'k', 'W', 'w'].includes(event.key)) {
                 event.preventDefault();
             }
        }

        // handleKeyUp 関数
        function handleKeyUp(event) {
             if (currentGameState !== GAME_STATE.PLAYING && currentGameState !== GAME_STATE.FINAL_BOSS) {
                 return;
             }
            switch (event.key) {
                case 'ArrowLeft':
                case 'a':
                    player.movingLeft = false;
                    break;
                case 'ArrowRight':
                case 'd':
                    player.movingRight = false;
                    break;
            }
        }

        // handleTouchStart 関数
        function handleTouchStart(event) {
            // ゲームプレイ中または最終ボス戦中のみ操作を有効にする (メッセージボックスやスタートボタンが表示されていない場合)
            if ((currentGameState === GAME_STATE.PLAYING || currentGameState === GAME_STATE.FINAL_BOSS) && messageBox.style.display === 'none' && startButtonContainer.style.display === 'none') {
                 isPointerDown = true;
                 // 複数のタッチを考慮せず、最初のタッチのみ使用
                 if (event.touches.length > 0) {
                     const touchX = event.touches[0].clientX;
                     const canvasRect = canvas.getBoundingClientRect();
                      // 画面座標からCanvas内の座標に変換
                     playerTargetX = (touchX - canvasRect.left) * (canvas.width / canvasRect.width);

                      // タッチ開始時にも発射（長押し連射対応）
                     if (playerShootCooldown <= 0) {
                         createPlayerProjectile();
                         if (loadedAudio.shoot) {
                             loadedAudio.shoot.play();
                         }
                         playerShootCooldown = PLAYER_SHOOT_COOLDOWN_MAX;
                     }
                 }
                 event.preventDefault(); // デフォルトのブラウザ動作（スクロール、ズームなど）を抑制
            } else if (currentGameState === GAME_STATE.START_SCREEN && startButtonContainer.style.display !== 'none') {
                 // スタート画面でタッチがあった場合、ボタンのクリックイベントを優先
                 // ここではpreventDefaultせず、ボタンのイベントリスナーに任せる
            } else if (currentGameState === GAME_STATE.GAME_OVER && messageBox.style.display !== 'none') {
                 // ゲームオーバー画面でタッチがあった場合、ボタンのクリックイベントを優先
                 // ここではpreventDefaultせず、ボタンのイベントリスナーに任せる
            } else if (currentGameState === GAME_STATE.LOADING) {
                 // ロード中は何もせずpreventDefault
                 event.preventDefault();
            }
        }

        // handleTouchMove 関数
        function handleTouchMove(event) {
            // ゲームプレイ中または最終ボス戦中、かつタッチが有効な場合のみプレイヤー位置を更新
            if ((currentGameState === GAME_STATE.PLAYING || currentGameState === GAME_STATE.FINAL_BOSS) && isPointerDown && messageBox.style.display === 'none' && startButtonContainer.style.display === 'none') {
                 if (event.touches.length > 0) {
                     const touchX = event.touches[0].clientX;
                     const canvasRect = canvas.getBoundingClientRect();
                     // 画面座標からCanvas内の座標に変換
                     playerTargetX = (touchX - canvasRect.left) * (canvas.width / canvasRect.width);
                 }
                event.preventDefault(); // デフォルトのブラウザ動作を抑制
            } else if (currentGameState === GAME_STATE.START_SCREEN || currentGameState === GAME_STATE.GAME_OVER || currentGameState === GAME_STATE.LOADING) {
                 // 他の画面状態ではタッチムーブも抑制
                 event.preventDefault();
            }
        }

        // handleTouchEnd 関数
        function handleTouchEnd(event) {
             // タッチ終了時にはプレイヤーの移動フラグをリセット
             // isPointerDown はタッチ/マウス共通なのでここではfalseにしない。
             // touchstart/mousedown で true になり、touchend/mouseup で false になる。
             // ただし、単一タッチの場合は isPointerDown を false にしてタッチ操作終了を示す。
             if (event.touches.length === 0) { // 全てのタッチが離れた場合
                 isPointerDown = false;
                 playerTargetX = null; // ターゲット位置もリセット
             }
            event.preventDefault(); // デフォルトのブラウザ動作を抑制
        }

        // handleMouseDown 関数 (PC向けマウス操作)
        function handleMouseDown(event) {
            // 左クリックのみ反応
            if (event.button === 0) {
                // ゲームプレイ中または最終ボス戦中のみ操作を有効にする (メッセージボックスやスタートボタンが表示されていない場合)
                if ((currentGameState === GAME_STATE.PLAYING || currentGameState === GAME_STATE.FINAL_BOSS) && messageBox.style.display === 'none' && startButtonContainer.style.display === 'none') {
                     isPointerDown = true;
                     const mouseX = event.clientX;
                     const canvasRect = canvas.getBoundingClientRect();
                     // 画面座標からCanvas内の座標に変換
                     playerTargetX = (mouseX - canvasRect.left) * (canvas.width / canvasRect.width);

                     // マウスプレス時にも発射（長押し連射対応）
                     if (playerShootCooldown <= 0) {
                         createPlayerProjectile();
                         if (loadedAudio.shoot) {
                             loadedAudio.shoot.play();
                         }
                         playerShootCooldown = PLAYER_SHOOT_COOLDOWN_MAX;
                     }
                } else if (currentGameState === GAME_STATE.START_SCREEN && startButtonContainer.style.display !== 'none') {
                     // スタート画面でクリックがあった場合、ボタンのクリックイベントを優先
                } else if (currentGameState === GAME_STATE.GAME_OVER && messageBox.style.display !== 'none') {
                     // ゲームオーバー画面でクリックがあった場合、ボタンのクリックイベントを優先
                } else if (currentGameState === GAME_STATE.LOADING) {
                     // ロード中は何もせず
                }
            }
        }

        // handleMouseMove 関数 (PC向けマウス操作)
        function handleMouseMove(event) {
            // ゲームプレイ中または最終ボス戦中、かつマウスが押されている場合のみプレイヤー位置を更新
            if ((currentGameState === GAME_STATE.PLAYING || currentGameState === GAME_STATE.FINAL_BOSS) && isPointerDown && messageBox.style.display === 'none' && startButtonContainer.style.display === 'none') {
                 const mouseX = event.clientX;
                 const canvasRect = canvas.getBoundingClientRect();
                 // 画面座標からCanvas内の座標に変換
                 playerTargetX = (mouseX - canvasRect.left) * (canvas.width / canvasRect.width);
            }
        }

        // handleMouseUp 関数 (PC向けマウス操作)
        function handleMouseUp(event) {
             // 左クリック終了時のみ反応
             if (event.button === 0) {
                isPointerDown = false;
                playerTargetX = null; // ターゲット位置もリセット
             }
        }


        // --- ゲーム開始 ---
        window.onload = init;

    </script>
</body>
</html>
